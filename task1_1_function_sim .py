# -*- coding: utf-8 -*-
"""Task1_1_Function_sim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14DdRqHHu1qYvLPDNvu4KxXrKLeiFtoEh
"""

pip install tensorflow==2.4

import tensorflow as tf
import numpy as np
import torch
import torchvision as tv
from torchvision import transforms, datasets
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import matplotlib.pyplot as plt
plt.style.use('seaborn-whitegrid')

simulatedInput = 20 * torch.rand((1000, 1)) - 10
groundTruthCos = np.cos(simulatedInput)
groundTruthSin = np.arcsinh(simulatedInput)

class ShallowSimNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(1, 272)
        self.fc2 = nn.Linear(272, 1)

    def forward(self, val):
        val = F.relu(self.fc1(val))
        val = self.fc2(val)
        return val

class MiddleSimNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(1, 32)
        self.fc2 = nn.Linear(32, 18)
        self.fc3 = nn.Linear(18, 8)
        self.fc4 = nn.Linear(8, 1)

    def forward(self, val):
        val = F.relu(self.fc1(val))
        val = F.relu(self.fc2(val))
        val = F.relu(self.fc3(val))
        val = self.fc4(val)
        return val    
    
class DeepSimNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(1, 32)
        self.fc2 = nn.Linear(32, 15)
        self.fc3 = nn.Linear(15, 10)
        self.fc4 = nn.Linear(10, 6)        
        self.fc5 = nn.Linear(6, 4)
        self.fc6 = nn.Linear(4, 1)        
        
    def forward(self, val):
        val = F.relu(self.fc1(val))
        val = F.relu(self.fc2(val))
        val = F.relu(self.fc3(val))
        val = F.relu(self.fc4(val))
        val = F.relu(self.fc5(val))
        val = self.fc6(val)
        return val

def calcParams(inputModel):
    val = sum(params.numel() for params in inputModel.parameters() if params.requires_grad)
    return val

model1 = ShallowSimNN()
model2 = MiddleSimNN()
model3 = DeepSimNN()



model1Params = calcParams(model1)
model2Params = calcParams(model2)
model3Params = calcParams(model3)
print(model1Params)
print(model2Params)
print(model3Params)

shallowCosNN = ShallowSimNN()
middleCosNN = MiddleSimNN()
deepCosNN = DeepSimNN()
shallowSinNN = ShallowSimNN()
middleSinNN = MiddleSimNN()
deepSinNN = DeepSimNN()
costFunc = nn.MSELoss()
shallowCosOpt = optim.Adam(shallowCosNN.parameters(), lr=0.001)
middleCosOpt = optim.Adam(middleCosNN.parameters(), lr=0.001)
deepCosOpt = optim.Adam(deepCosNN.parameters(), lr=0.001)
shallowSinOpt = optim.Adam(shallowSinNN.parameters(), lr=0.001)
middleSinOpt = optim.Adam(middleSinNN.parameters(), lr=0.001)
deepSinOpt = optim.Adam(deepSinNN.parameters(), lr=0.001)

EPOCHS = 2000
counter = 0
counterList = []
shallowCosCostList = []
for index in range(EPOCHS):
    counterList.append(counter)
    counter += 1
    shallowCosNN.zero_grad()
    output = shallowCosNN(simulatedInput)
    cost = costFunc(output, groundTruthCos)
    shallowCosCostList.append(cost)
    cost.backward()
    shallowCosOpt.step()

middleCosCostList = []
for index in range(EPOCHS):
    middleCosNN.zero_grad()
    output = middleCosNN(simulatedInput)
    cost = costFunc(output, groundTruthCos)
    middleCosCostList.append(cost)
    cost.backward()
    middleCosOpt.step()    
    
deepCosCostList = []
for index in range(EPOCHS):
    deepCosNN.zero_grad()
    output = deepCosNN(simulatedInput)
    cost = costFunc(output, groundTruthCos)
    deepCosCostList.append(cost)
    cost.backward()
    deepCosOpt.step()

shallowSinCostList = []
for index in range(EPOCHS):
    shallowSinNN.zero_grad()
    output = shallowSinNN(simulatedInput)
    cost = costFunc(output, groundTruthSin)
    shallowSinCostList.append(cost)
    cost.backward()
    shallowSinOpt.step()

middleSinCostList = []
for index in range(EPOCHS):
    middleSinNN.zero_grad()
    output = middleSinNN(simulatedInput)
    cost = costFunc(output, groundTruthSin)
    middleSinCostList.append(cost)
    cost.backward()
    middleSinOpt.step()    
    
deepSinCostList = []
for index in range(EPOCHS):
    deepSinNN.zero_grad()
    output = deepSinNN(simulatedInput)
    cost = costFunc(output, groundTruthSin)
    deepSinCostList.append(cost)
    cost.backward()
    deepSinOpt.step()

plt.plot(counterList, deepSinCostList, 'c', label='Deep-5')
plt.plot(counterList, middleSinCostList, 'm', label='Middle-3')
plt.plot(counterList, shallowSinCostList, 'y', label='Shallow-1')

plt.title("Learning Progression - arcsinh(x)")
plt.xlabel("Number of EPOCHS")
plt.ylabel("Error")
plt.legend(loc="upper right")
plt.show()

plt.plot(counterList, deepCosCostList, 'c', label='Deep-5')
plt.plot(counterList, middleCosCostList, 'm', label='Middle-3')
plt.plot(counterList, shallowCosCostList, 'y', label='Shallow-1')

plt.title("Learning Progression - cos(x)")
plt.xlabel("Number of EPOCHS")
plt.ylabel("Error")
plt.legend(loc="upper right")
plt.show()

simulatedInput = 20 * torch.rand((1000, 1)) - 10
groundTruthCos = np.cos(simulatedInput)
groundTruthSin = np.arcsinh(simulatedInput)


shallowCosOutput = shallowCosNN(simulatedInput)
middleCosOutput = middleCosNN(simulatedInput)
deepCosOutput = deepCosNN(simulatedInput)
shallowSinOutput = shallowSinNN(simulatedInput)
middleSinOutput = middleSinNN(simulatedInput)
deepSinOutput = deepSinNN(simulatedInput)

plt.plot(simulatedInput, shallowSinOutput.tolist(), 'y.', label='Shallow-1')
plt.plot(simulatedInput, middleSinOutput.tolist(), 'm.', label='Middle-3')
plt.plot(simulatedInput, deepSinOutput.tolist(), 'c.', label='Deep-5')
plt.plot(simulatedInput, groundTruthSin.tolist(), 'r.', label='Ground Truth')
plt.title("Predictions of Models - (1/5)arcsinh(6x)")
plt.xlabel("input value")
plt.ylabel("output value")
plt.legend(loc="lower right")
plt.show()

plt.plot(simulatedInput, shallowCosOutput.tolist(), 'y.', label='Shallow-1')
plt.plot(simulatedInput, middleCosOutput.tolist(), 'm.', label='Middle-3')
plt.plot(simulatedInput, deepCosOutput.tolist(), 'c.', label='Deep-5')
plt.plot(simulatedInput, groundTruthCos.tolist(), 'r.', label='Ground Truth')
plt.title("Predictions of Models - cos(x)")
plt.xlabel("input value")
plt.ylabel("output value")
plt.legend(loc="lower right")
plt.show()